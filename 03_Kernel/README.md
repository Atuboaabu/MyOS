# 内核编写
## 一、保护模式&实模式
### 1、实模式和保护模式概述
在 x86 处理器架构中，保护模式和实模式是两种不同的运行模式，各自有不同的特性和应用场景。  
#### 实模式
实模式是 x86 处理器在启动时的默认模式，它模拟了早期的 8086 处理器环境，主要用于简单的操作系统和早期的 DOS 程序。  

**特点：**  
- 内存寻址：使用 20 位地址总线，可访问 1 MB 的内存（2^20 = 1MB）。  
- 分段寻址：使用段寄存器（如 CS, DS, SS, ES）进行分段寻址。内存地址由段寄存器和偏移量计算得出，段地址左移 4 位加上偏移量形成物理地址。  
- 无内存保护：程序可以直接访问全部内存，没有权限控制或内存隔离，可能导致不同程序相互干扰。  
- 简单环境：不支持虚拟内存、硬件级别的进程隔离、特权级等功能，只能运行单任务，适合小型或早期的系统。  

**用途：**  
- 主要用于引导程序、BIOS、DOS 系统以及一些早期的 16 位程序。  
- 引导加载器通常在实模式下启动操作系统（如 MBR 的执行）。  

#### 保护模式
保护模式是 80286 及以上处理器支持的一种模式，提供了更多的内存管理和保护机制。现代操作系统（如 Windows、Linux）都在保护模式下运行。  

**特点：**  
- 32 位地址空间：支持 32 位地址总线，可访问 4 GB 内存（2^32 = 4GB）。
- 段选择器和页表：使用段选择器和页表进行内存管理。段寄存器在保护模式下不直接存储段地址，而是作为段选择器，指向段描述符表，进一步划分内存。
- 内存保护：每个段都有访问权限和限长设置，可以有效保护内存区域，防止非法访问。
- 多任务和特权级：支持硬件级别的进程隔离和多任务调度。引入特权级（0-3 级），内核程序一般在 0 级，应用程序在 3 级，从而提供安全隔离。
- 虚拟内存：通过页表支持虚拟内存管理，使物理内存可以被映射到更大的虚拟地址空间，提高内存管理的灵活性。  

**用途:**  
- 现代操作系统内核都在保护模式下运行，以实现多任务、安全隔离和虚拟内存管理。
- 支持复杂系统的软件执行，包括现代应用程序和服务。

#### 对比
![实模式&保护模式对比](../00_image/mode_comparison.png)  
实模式主要用于系统启动阶段，保护模式则是现代系统运行的主要模式，能够充分利用处理器的高级功能。  

## 二、全局描述符
### 1、段描述符
在保护模式下，段描述符（Segment Descriptor）是存储在段描述符表（GDT 或 LDT）中的数据结构，用于定义内存段的属性。每个段描述符包含段的基址、限长、权限和其他控制信息。通过段描述符，保护模式可以实现灵活的内存管理和内存保护。  
一个段描述符占 8 个字节（64 位），其中包含了段的基址、限长以及访问控制字段。以下是段描述符的主要字段及其含义：  
![段描述符结构](../00_image/segment_description.png)  

**详细字段解释：**  
1. 段限长（Limit）：段限长定义了段的大小，表示段内的最大偏移地址。段限长的单位由 G 位决定：
- G 位 = 0：段限长以字节为单位，最大 1 MB（2^20 字节）。  
- G 位 = 1：段限长以 4 KB 为单位，最大 4 GB（2^32 字节）。    
2. 基址（Base）：段基址定义了段的起始地址。段基址分为低 16 位、中间 8 位和高 8 位，总共 32 位，用于定位段在内存中的起始位置。  
3. 类型（Type）：类型字段用于指定段的种类和访问权限。
- 代码段：指令执行方向、可读性等。
- 数据段：段是否可写、可读等。
- 系统段：如任务状态段（TSS），用于任务管理。  
4. S 位（Descriptor Type）：标识描述符的类型，1 表示代码段或数据段，0 表示系统段。  
5. DPL（Descriptor Privilege Level）：描述符的权限级别，共有 4 个特权级别（0-3），数值越小权限越高。
- 内核段通常设置为 0 级，应用程序段通常设置为 3 级。
6. P 位（Present）：段存在位，1 表示段存在于内存中，0 表示段不存在。如果程序尝试访问 P 位为 0 的段，会触发异常。  
7. G 位（Granularity）：粒度位，用于控制段限长的单位。1 表示限长以 4 KB 为单位，0 表示以字节为单位。  
8. D/B 位：默认操作大小/下限位。对于代码段，1 表示 32 位操作，0 表示 16 位操作。  
9. L 位（64 位代码段）：在 64 位模式下使用，1 表示 64 位代码段。此位仅在 x86-64 架构中有效。    

**段描述符的分类：**  
在保护模式下，段描述符分为以下几种类型：  
1. 代码段描述符：用于描述可执行代码的内存段。
- 可以设置段的可读性（只读或可读可执行）。
- 代码段通常在 Ring 0（内核）或 Ring 3（用户态）中使用。
2. 数据段描述符：用于描述存储数据的内存段。
- 可以设置段的读写权限（只读或可读写）。
- 数据段也可以根据需求设置特权级。
3. 系统段描述符：用于定义特殊用途的段，例如任务状态段（TSS）、局部描述符表（LDT）。
- 系统段的 S 位为 0。
- 任务状态段（TSS）描述符用于多任务管理，LDT 描述符用于进程独立的段管理。

**段描述符的工作过程：**  
1. 段选择器访问段描述符：在保护模式下，段寄存器存储的值称为段选择器，用于指向段描述符。  
2. 段描述符控制段的访问：段描述符中包含了段的基址、限长、类型和权限等信息。当程序访问内存段时，CPU 会检查段描述符的 P 位和 DPL 等字段，以确保访问符合权限。  
3. 地址转换：通过段基址和偏移量，CPU 计算出线性地址，再通过页表映射到物理地址（如果启用了分页机制）。  

### 2、全局描述符表(GDT)
全局描述符表（GDT，Global Descriptor Table） 是 x86 处理器在保护模式下用来定义内存段属性的核心结构。GDT 是一个数组，其中的每一项都是一个 8 字节（64 位）的段描述符，每个描述符定义一个段的基址、大小、权限等信息。GDT 允许操作系统对代码段、数据段、系统段（如 TSS 段）进行精细化的控制和保护。   

#### GDT 的作用
GDT 是保护模式内存管理的关键部分，主要作用包括：  
1. 定义内存段：通过段描述符，GDT 可以定义代码段、数据段和系统段的基址、限长和权限。  
2. 权限管理：通过特权级（DPL），GDT 可以设置不同段的访问权限，从而在多任务环境中实现内存隔离和安全。  
3. 任务管理：GDT 中包含 TSS 段描述符，可以用来进行任务切换，便于多任务系统的实现。  
4. 地址转换：GDT 配合段寄存器，实现逻辑地址到线性地址的转换。  

#### GDT 初始化步骤  
在进入保护模式之前，需要初始化 GDT 并加载到 GDTR 寄存器中。通常的步骤如下：  
1. 定义 GDT 表和段描述符：在内存中分配 GDT 空间，定义代码段、数据段和系统段（如 TSS 段）的描述符。  
2. 设置 GDTR 寄存器：使用 LGDT 指令将 GDT 的基地址和限长加载到 GDTR 寄存器。  
3. 切换到保护模式：设置 CR0 控制寄存器的 PE 位（保护模式启用位），然后跳转到保护模式下的代码。  
4. 加载段选择器：将段选择器加载到段寄存器中，使 CPU 使用 GDT 中的描述符来解析逻辑地址。  

#### GDT 示例
```asm
; 定义gdt
gdt_start:
    .quad 0x0000000000000000       ; GDT 的第一个描述符为 NULL 描述符
    .quad 0x00cf9a000000ffff       ; 代码段描述符，基址=0，限长=4GB，权限=可执行+只读
    .quad 0x00cf92000000ffff       ; 数据段描述符，基址=0，限长=4GB，权限=可读写

gdt_end:
gdt_ptr:
    .word gdt_end - gdt_start - 1  ; GDT 长度
    .long gdt_start                ; GDT 基址

;加载gdt
    lgdt [gdt_ptr]      ; 加载 GDT 基址和限长到 GDTR 寄存器
    mov eax, cr0
    or eax, 0x1         ; 设置保护模式位
    mov cr0, eax
    jmp CODE_SEG:init   ; 跳转到保护模式代码段
```

#### GDT 的重要性  
1. 内存隔离：GDT 配合 DPL 实现内存隔离，避免低权限代码访问高权限段。  
2. 系统安全性：GDT 提供的内存保护机制有助于实现用户态和内核态的隔离。  
3. 多任务管理：GDT 中可以包含 TSS 描述符，用于实现任务切换和进程管理。  

### 3、局部描述符(LDT)
局部描述符表（LDT，Local Descriptor Table） 是保护模式下的一种描述符表，类似于全局描述符表（GDT），用于管理段描述符。与 GDT 不同的是，LDT 主要用于进程或线程的局部内存管理，它提供了一种机制，使每个任务（例如进程）可以拥有自己的地址空间，从而实现进程间的内存隔离。  
#### LDT 的作用  
LDT 的作用是提供每个任务（通常是进程）一组专用的段描述符，用于定义进程的代码段、数据段和堆栈段等。这样可以实现以下功能：  
1. 内存隔离：每个进程的 LDT 可以独立定义段描述符，从而使进程可以拥有独立的内存空间。  
2. 特权控制：LDT 中的段描述符可以设置不同的特权级，控制访问权限。  
3. 灵活性：LDT 可以根据进程的需求定义不同的段，便于管理多任务系统。  

#### LDT 与 GDT 的区别
![LDT与GDT的区别](../00_image/LDT_GDT_diff.png)  

#### LDT 的使用过程
1. 定义 LDT 表：在内存中为每个任务创建一个 LDT，定义该任务的代码段、数据段和堆栈段描述符。
2. 加载 LDT：将 LDT 的基地址和限长加载到 LDTR 寄存器。每次任务切换时，操作系统会更新 LDTR，使新任务能够使用自己的 LDT。
3. 访问 LDT 段：通过段选择器的 TI 位选择 LDT，然后使用段选择器的描述符索引访问 LDT 中的段描述符。

#### LDT 示例
```asm
ldt_start:
    .quad 0x00cf9a000000ffff       ; 代码段描述符，基址=0，限长=4GB
    .quad 0x00cf92000000ffff       ; 数据段描述符，基址=0，限长=4GB

ldt_ptr:
    .word ldt_end - ldt_start - 1  ; LDT 的限长
    .long ldt_start                ; LDT 的基址

ldt_end:
```  
在这个示例中，我们定义了两个段描述符，一个用于代码段，另一个用于数据段。然后我们可以将 ldt_ptr 加载到 LDTR 中，切换到这个 LDT。  

#### LDT 的重要性
1. 进程隔离：LDT 使每个进程都可以拥有独立的内存段，从而实现进程间的隔离。
2. 灵活性：LDT 允许根据每个进程的需求定制段描述符，为系统的内存管理提供了灵活性。
3. 保护机制：通过 RPL 和特权级控制，可以避免低权限进程访问高权限段，从而提高系统安全性。

### 4、选择子(selector)
选择子（Selector） 是保护模式下的一种特殊值，用于在段寄存器中引用内存段。它并不直接包含段的基址或限长，而是一个索引，指向 GDT（全局描述符表）或 LDT（局部描述符表）中的一个段描述符。CPU 通过该段描述符来获取段的实际基址、大小和权限等信息，从而实现对段的访问和保护。  

#### selector 结构
选择子是一个 16 位的值，由以下几个部分组成：  
![选择子结构](../00_image/selector.png)  

**各个字段的作用如下：**  
1. RPL（请求特权级）：用于指定选择子的特权级（0 到 3），其中 0 是最高级别，3 是最低级别。RPL 用于确定在不同特权级的访问控制中是否可以访问某个段。RPL 通常和段描述符中的 DPL（描述符特权级）一起工作，以判断是否允许当前代码访问某段。  
2. TI 位（表指示位）：用于指定选择子指向 GDT 还是 LDT：  
- TI = 0 表示指向 GDT。  
- TI = 1 表示指向 LDT。  
3. 描述符索引：用于在 GDT 或 LDT 中定位段描述符。描述符索引从 0 开始，指定选择子在描述符表中的具体位置。CPU 通过描述符索引，从 GDT 或 LDT 中找到对应的段描述符。  

#### selector 的使用
选择子通常被加载到段寄存器（如 CS、DS、SS 等）中，用于访问不同的内存段。在保护模式下，段寄存器存储的内容是一个选择子，而不是实际的段基址。加载选择子到段寄存器时，CPU 会自动根据选择子的 TI 位和描述符索引，从 GDT 或 LDT 中查找对应的段描述符。  

#### selector 工作机制  
当 CPU 需要访问某个段时，按照以下步骤工作：  
1. 加载选择子：将选择子加载到段寄存器，如 mov ax, selector 然后 mov ds, ax。
2. 解析选择子：CPU 根据选择子的 TI 位确定访问 GDT 还是 LDT。
3. 查找段描述符：根据描述符索引，在指定的描述符表中找到对应的段描述符。
4. 获取段属性：CPU 从段描述符中读取段基址、限长和访问权限等信息。
5. 访问段内容：根据段基址和偏移量（段内偏移）计算逻辑地址，再转换为线性地址，完成对段内容的访问。

#### 特权级检查
在保护模式下，CPU 使用 RPL、DPL（描述符特权级）和 CPL（当前特权级）来确定是否允许当前代码访问某个段。这些特权级控制机制确保了不同权限级别的代码只能访问允许的段，从而实现了内存保护。  

**特权级检查规则：**  
- 访问数据段：段的 DPL ≥ max(CPL, RPL)，则允许访问；否则拒绝访问。
- 访问代码段：段的 DPL = CPL，且段为可执行段，则允许访问；否则拒绝访问。  

